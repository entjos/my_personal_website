{
  "hash": "9beb801dfbf40c924d03e8ed23f49f73",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Optimisation of a stratified Cox model using Optimx()\"\ndescription: \"In this blog post we are going to fit a stratified Cox regression model by optimising its likelihood function with `Optimx::optimx()`. Stratified Cox regression models allow one to relax the assumption of proportional hazards over time between different exposure groups.\"\nauthor: \"Joshua Philipp Entrop\"\ndate: \"2021-04-12\"\ncategories: [Optimisation, R, survival analysis]\ntags: [R, survival analysis, manual optimisation]\ndraft: FALSE\n---\n\n\n[R Code](https://www.joshua-entrop.com/rcode/optim_cox_stratified.txt){.btn .btn-outline-primary .btn role=\"button\"}\n\n\n\n\n\nIn this blog post we are going to fit a stratified Cox regression model by optimising its likelihood function with `Optimx::optimx()`. Stratified Cox regression models allow one to relax the assumption of proportional hazards over time between different exposure groups. This is the main assumption we usually have to make when using Cox regression models. However, to assume proportional hazards is in most situations a quite unrealistic and not sensitive assumption. In this post we will discuss one way to relax this assumption in situations in which one is not interested in the effect estimates of the variable for which we assume non-proportional hazards. This post is a follow-up of my [post](https://www.joshua-entrop.com/post/optim_cox.html) on Cox proportional hazard models. Hence, I will skip some of the parts which are explained there. If you're interested you can download the `R` code used in this blog post as `.txt` file [here](https://www.joshua-entrop.com/rcode/optim_cox_stratified.txt).\n\nThe term stratification usually refers to a situation in which we split our dataset according to some variables $Z$ in order to allow interactions between these variables and other independent variables $\\mathbf{X}$ in the model. Using stratification in this way allows us to obtain a separate effect estimate for our exposure of interest for each strata of $Z$. However, when we talk about stratification in the context of Cox regression models, we refer to a slightly different concept. Stratification in a stratified Cox model does not allow for interaction between $Z$ and $\\mathbf{X}$. It instead allows for non-proportional hazards of $Z$ across time $t$, by assuming different baseline hazards $h_{0z}(t)$ within each strata. However, since we don't model the baseline hazard when fitting a Cox regression model, we cannot obtain estimates for the effect of $Z$ when fitting a stratified Cox regression model.\n\nLet's take a look at an example. For this post we will use the `survival::lung` dataset again. For more information on the dataset see `?survival::lung`. This time we will model the effect of age and physical functioning measured using the ECOG score on survival of patients with advanced lung cancer. First, we need to set up our data set and remove ties of event times for demonstration purposes as we did in the previous posts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Prefix -------------------------------------------------------------------\n\n# Remove all files loaded in the global environment\nrm(list = ls())\n\n# Loading packages\nlibrary(survival)\nlibrary(optimx)\nlibrary(numDeriv)\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(broom)\n\n# 2. Loading data set ---------------------------------------------------------\n\n#Reading the example data set lung from the survival package\nlung <- as.data.frame(survival::lung)\n\n#Recode dichotomous variables\nlung$female    <- ifelse(lung$sex == 2, 1, 0)\nlung$status_n  <- ifelse(lung$status == 2, 1, 0)\nlung$ecog_high <- ifelse(lung$ph.ecog %in% c(0, 1), 0, 1)\n\n#Removes time ties in data set\nset.seed(2687153)\nlung$time <- map_dbl(lung$time,\n                     function(x){x + runif(1, -0.1, +0.1)})\n```\n:::\n\n\nWe are now going to fit a common Cox proportional hazard model with `survival::coxph()`. Afterwards, we can check the proportionality assumption for each covariate in the model using Schönefeld residuals. For this we will use the `survival::cox.zph()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3. Check for non-proportional effect in our simple cox-model ----------------\n\n# Fit a cox model\ncox_model <- coxph(Surv(time, status_n == 1) ~ ecog_high + age + female,\n                   data = lung)\n\n# Check for non-proportional effects using Schönefeld residuals\ncox.zph(cox_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          chisq df     p\necog_high 3.030  1 0.082\nage       0.195  1 0.659\nfemale    3.586  1 0.058\nGLOBAL    6.285  3 0.099\n```\n\n\n:::\n:::\n\n\nThe output gives us a test of non-proportionality of effects for each variable. The null hypothesis for this test is proportionality of effects. Hence, small p-values gives us a hint whether we can assume that the effect of certain covariates is not proportional over time. However, assuming proportionality of effects is always a strong assumption and hence, it might nevertheless be useful to fit a model that relaxes this assumption at least for some variables.\n\nIn our example it looks like there might be a non-proportional effect for the variables `ecog_high` and `female`. We cannot use our method of stratification in Cox models to account for non-proportional effects of `ecog_high`, since `ecog_high` is our exposure of interest and we therefore want to obtain an estimate of its effect on survival. In our example, `female` is a variable we use for adjustment and for the sake of demonstration we are not interested in its effect estimate. Hence, we can use a stratified Cox model for sex to deal with the non-proportionality of its effect on survival.\n\nTo conclude, for the rest of the blog post we are going to fit a stratified Cox proportional hazard model for the effect of high ECOG score stratified by sex. The Cox model in its general form follows:\n\n$$ \\lambda(t|X) = \\lambda_0(t) \\exp(\\beta X). $$\n\nIn our case we will fit the following Cox model including the independent variables high ECOG score $(x_1)$ and age $(x_2)$.\n\n$$ \\lambda(t|X) = \\lambda_0(t) \\exp(\\beta_1  x_{1} + \\beta_2  x_{2}). $$\n\nNow you might wonder where we left our third covariate `female`. This covariate is now used in our likelihood function to allow for different baseline hazards $h_{0Z}(t)$ with $Z$ equals to the strata of `female`. The log-likelihood for our stratified Cox model in this case is the sum of the log-likelihood values across strata of $Z$ i.e. values of `female`. Formally, we can define our log-likelihood function as\n\n$$ \n\\begin{split}\n& \\ln L(\\beta) = \\sum_z \\ln L(\\beta_z) \\\\ \n& \\ln L(\\beta) =\\sum_z\\sum_i d_{zi} \\bigg( X_{zi} \\beta - \\ln \\sum_{j:t_j\\geq t_i} \\theta_{zj} \\bigg) \\end{split} \\\\\n$$\n\nwhere $\\theta_z = \\exp(\\beta X_z)$ and $d_{zi}$ is the event indicator for the $i^{th}$ subject within the $z^{th}$ strata. If we plug in our independent variables from above we yield $\\theta_z = \\exp(\\beta_1 x_{z1} + \\beta_2 x_{z2})$ for our specific case. Note, that the coefficients $\\beta_1$ and $\\beta_2$ are the same in all strata of $Z$. That is the reason why we do not obtain different effect estimates across levels of $Z$. We assume that the effect of $\\beta_1$ and $\\beta_2$ is still the same in all strata of $Z$. This is fundamentally different to the usual concept of stratification where we would assume that $\\beta_1$ and $\\beta_2$ change across strata of $Z$.\n\nNow, lets take this formula and write it as a function in `R`. Also this time we will compute $\\sum_{j:t_j\\geq t_i} \\theta_{zj}$ using the `base::cumsum()` function to calculate the cumulative sum of $\\theta_j$ across the event times $t$ in descending order. Only this time we will calculate two $\\theta_{zj}$ one for each strata of female, i.e. males and females.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 4. Define log-likelihood function for stratified Cox regression model -------\nnegll <- function(par){\n\n  #Extract guesses for beta1 and beta2\n  beta1 <- par[1]\n  beta2 <- par[2]\n\n  #Define dependent and independent variables\n  m <- data.frame(t = lung$time,\n                  d = lung$status_n,\n                  x1 = lung$ecog_high,\n                  x2 = lung$age,\n                  z  = lung$female)\n\n  #Calculate theta\n  m$theta <- exp(beta1 * m$x1 + beta2 * m$x2)\n\n  #Calculate cumulative sum of theta with descending t for strata z == 0\n  mz0 <- m %>%\n    filter(z == 0) %>%\n    arrange(desc(t)) %>%\n    mutate(thetaj = cumsum(theta))\n\n  #Calculate cumulative sum of theta with descending t for strata z == 1\n  mz1 <- m %>%\n    filter(z == 1) %>%\n    arrange(desc(t)) %>%\n    mutate(thetaj = cumsum(theta))\n\n  #Estimate negative log likelihood value\n  val_z0 <- sum(mz0$d * ((mz0$x1 * beta1 + mz0$x2 * beta2) - log(mz0$thetaj)))\n  val_z1 <- sum(mz1$d * ((mz1$x1 * beta1 + mz1$x2 * beta2) - log(mz1$thetaj)))\n\n  val <- -sum(val_z0, val_z1)\n\n  return(val)\n}\n```\n:::\n\n\nIn the next step we will define the gradient function for our log-likelihood function, which we can use to improve the optimisation process. The gradient function for the stratified Cox model in general follows\n\n$$ \\ln L'(\\beta) = \\sum_{z} \\sum_{i} d_{zi} \\bigg(X_{zi} - \\frac{\\sum_{j:t_j\\geq t_i} \\theta_{zj} X_{zj}}{\\sum_{j:t_j\\geq t_i} \\theta_{zj}} \\bigg)$$\n\nIn our case we yield the following two gradient functions for $\\beta_1$ and $\\beta_2$.\n\n$$ \\ln L'(\\beta_1) = \\sum_{z} \\sum_{i} d_{zi} \\bigg(x_{1zi} - \\frac{\\sum_{j:t_j\\geq t_i} \\theta_{zj} x_{1zj}}{\\sum_{j:t_j\\geq t_i} \\theta_{zj}} \\bigg)$$\n\n$$ \\ln L'(\\beta_2) = \\sum_{z} \\sum_{i} d_{zi} \\bigg(x_{2zi} - \\frac{\\sum_{j:t_j\\geq t_i} \\theta_{zj} x_{2zj}}{\\sum_{j:t_j\\geq t_i} \\theta_{zj}} \\bigg)$$ We can now write these as functions in `R`, where each gradient function will be the sum of gradient functions within each strata.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 5. Define gradient function for stratified Cox regression model -------------\nnegll_grad <- function(par){\n\n  #Extract guesses for beta1 and beta2\n  beta1 <- par[1]\n  beta2 <- par[2]\n\n  #Create output vector\n  n <- length(par[1])\n  gg <- as.vector(rep(0, n))\n\n  #Define dependent and independent variables\n  m <- data.frame(t = lung$time,\n                  d = lung$status_n,\n                  x1 = lung$ecog_high,\n                  x2 = lung$age,\n                  z  = lung$female)\n\n  #Calculate theta\n  m$theta <- exp(beta1 * m$x1 + beta2 * m$x2)\n\n  #Calculate thetaj, thetajx1 and thetajx2 for strata z == 0\n  mz0 <- m %>%\n    filter(z == 0) %>%\n    arrange(desc(t)) %>%\n    mutate(thetaj = cumsum(theta),\n           thetajx1 = cumsum(theta * x1),\n           thetajx2 = cumsum(theta * x2))\n\n  #Calculate thetaj, thetajx1 and thetajx2 for strata z == 1\n  mz1 <- m %>%\n    filter(z == 1) %>%\n    arrange(desc(t)) %>%\n    mutate(thetaj = cumsum(theta),\n           thetajx1 = cumsum(theta * x1),\n           thetajx2 = cumsum(theta * x2))\n\n  #Calculate partial gradient functions for x1 within strata of z\n  gg_x1_z0 <- sum(mz0$d * (mz0$x1 - (mz0$thetajx1 / mz0$thetaj)))\n  gg_x1_z1 <- sum(mz1$d * (mz1$x1 - (mz1$thetajx1 / mz1$thetaj)))\n\n  #Calculate partial gradient functions for x2 within strata of z\n  gg_x2_z0 <- sum(mz0$d * (mz0$x2 - (mz0$thetajx2 / mz0$thetaj)))\n  gg_x2_z1 <- sum(mz1$d * (mz1$x2 - (mz1$thetajx2 / mz1$thetaj)))\n\n  #Calculate gradient for x1 and x2 as the sum of the gradients within z\n  gg[1] <- -sum(gg_x1_z0, gg_x1_z1)\n  gg[2] <- -sum(gg_x2_z0, gg_x2_z1)\n\n  return(gg)\n}\n```\n:::\n\n\nFrom here onward we can just use the same process as we did in the [previous blog post](https://www.joshua-entrop.com/post/optim_cox.html) on optimising a Cox regression model.\n\nWe first compare our gradient function with its approximation calculated with the `numDerive::grad()` function to see if we specified the function correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 5.1 Compare gradient function with numeric approximation of gradient ========\n# compare gradient at 0, 0\nmygrad <- negll_grad(c(0, 0))\nnumgrad <- grad(x = c(0, 0), func = negll)\n\nall.equal(mygrad, numgrad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nLooks like we get the same numbers and our gradient functions works fine.\n\nNow we pass both our log-likelihood and gradient function on to our `optimx()` call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 6. Find minimum of log-likelihood function ----------------------------------\n# Passing names to the values in the par vector improves readability of results\nopt <- optimx(par = c(beta_ecog = 0, beta_age = 0), \n              fn = negll,\n              gr = negll_grad,\n              hessian = TRUE,\n              control = list(trace = 0, all.methods = TRUE))\n\n# Show results for optimisation algorithms, that converged (convcode != 9999)\nsummary(opt, order = \"value\") %>%\n  rownames_to_column(\"algorithm\") %>%\n  filter(convcode != 9999) %>%\n  arrange(value) %>%\n  select(algorithm, beta_ecog, beta_age, value) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  algorithm beta_ecog   beta_age   value\n1       nlm 0.6927350 0.01056682 634.995\n2    Rcgmin 0.6927350 0.01056682 634.995\n3    nlminb 0.6927352 0.01056683 634.995\n4      BFGS 0.6927361 0.01056662 634.995\n5  L-BFGS-B 0.6927383 0.01056691 634.995\n```\n\n\n:::\n:::\n\n\nMost optimisation algorithms implemented in the `{optimx}` yield very similar likelihood values. This is a good indication that we actually found the maximum likelihood estimate for our coefficients.\n\nLet us now compare our estimates with the estimates we would obtain from the `survival::coxph()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 7. Estimate regression coefficients using coxph  ----------------------------\ncox_model <- coxph(Surv(time, status_n == 1) ~ ecog_high + age+ strata(female),\n                   data = lung)\n\n# 8. Comparing results from optimx and coxph ----------------------------------\ncoef_coxph <- unname(coef(cox_model))\ncoef_opt <- coef(opt)\n\nlapply(1:nrow(coef_opt), function(i){\n\n  opt_name <- attributes(coef_opt)$dimnames[[1]][i]\n\n  diff_beta_1 <- (coef_opt[i, 1] - coef_coxph[1])\n  diff_beta_2 <- (coef_opt[i, 2] - coef_coxph[2])\n\n  mean_dif <- mean(diff_beta_1, diff_beta_2,\n                   na.rm = TRUE)\n\n  data.frame(opt_name, mean_dif)\n\n}) %>%\n  bind_rows() %>%\n  filter(!is.na(mean_dif)) %>%\n  mutate(mean_dif = abs(mean_dif)) %>%\n  arrange(mean_dif)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     opt_name     mean_dif\n1      Rcgmin 4.175072e-09\n2         nlm 8.453764e-09\n3      nlminb 1.850497e-07\n4        BFGS 1.109537e-06\n5    L-BFGS-B 3.309779e-06\n6 Nelder-Mead 6.716166e-04\n7          CG 1.226977e-01\n8      Rvmmin 6.927350e-01\n```\n\n\n:::\n:::\n\n\nWe can see that the mean difference between our estimates and the estimates yielded with the `survival::coxph()` model is small for most of our models, especially for the estimates obtained with the `nlm` algorithm.\n\nAt the end let us just compute the standard error for our estimates using the hessian matrix. For some more explanation take a look at this [previous blog post](https://www.joshua-entrop.com/post/optim_logit_reg_se.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 9. Estimate the standard error ----------------------------------------------\n\n# Extract hessian matrix for the nlm optimisation\nhessian_m <- attributes(opt)$details[\"nlm\", ][[\"nhatend\"]]\n\n# Estimate se based on hessian matrix\nfisher_info <- solve(hessian_m)\nprop_se  <- sqrt(diag(fisher_info))\n\n# Compare the estimated se from our model with the one from the Coxph model\nses <- data.frame(se_nlm    = prop_se,\n                  se_coxph  = tidy(cox_model)[[\"std.error\"]]) %>%\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       se_nlm    se_coxph\n1 0.179171323 0.179171322\n2 0.009300492 0.009300492\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(ses[,\"se_nlm\"], ses[, \"se_coxph\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nBased on the standard error, we can now calculate the confidence intervals for our estimates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 10. Estimate 95%CIs using estimation of SE ----------------------------------\n\n# Extracting estimates from the nlm optimisaiton\ncoef_test <- coef(opt)[\"nlm\",]\n\n# Compute 95%CIs\nupper <- coef_test + 1.96 * prop_se\nlower <- coef_test - 1.96 * prop_se\n\n# Print estimate with 95%CIs\ndata.frame(Estimate = coef_test,\n           CI_lower = lower,\n           CI_upper = upper,\n           se       = prop_se) %>%\n  round(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Estimate CI_lower CI_upper     se\nbeta_ecog   0.6927   0.3416   1.0439 0.1792\nbeta_age    0.0106  -0.0077   0.0288 0.0093\n```\n\n\n:::\n:::\n\n\nPerfect! We obtained our own stratified Cox model with confidence intervals.\n\nTo recap, we started this post with assessing the proportional hazard assumption for a common Cox proportional hazard model. While doing this, we found that some of the variables included in the model most likely have no proportional effects across the time of follow up. To deal with this issue we estimated a stratified Cox regression model stratified by sex by optimising its log-likelihood function. I hope this post gave some insides how stratified Cox models work and how they differ from common stratification methods.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}